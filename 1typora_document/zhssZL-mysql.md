
3. 
接解优执

对他加锁之后，而且还把更新前的旧值写入undo日志文件
之后，我们就可以正式开始更新这行记录了，更新的时候，先是会更新缓冲池中的记录，此时这个数据就是脏数据
了。

- 为什么叫脏数据？
因为buffer pool和undo log 更新了，但是硬盘没有更新。

redo log 记录新数据
当这个参数的值为1的时候，你提交事务的时候，就必须把redo log从内存刷入到磁盘文件里去，只要事务提交成功，那么redo log就
必然在磁盘里了，

bin log 不是属于特定存储引擎，而是mysql server的
sync_binlog参数可以控制binlog的刷盘策略
0 刷入os cache
1 刷入磁盘文件

同时给redo log 写入一个commit标记才算提交事务。

开发经验
Java应用系统部署的时候常选用的机器配置大致是2核4G和4核8G的较多一些，
数据库部署的时候常选用的机器配置最低在8核16G以上，正常在16核32G

- java程序
4核8G的机器部署普通的Java应用系统，每秒大致就是抗下几百的并发访问，从每秒一两百请求到每秒七八百请
求，都是有可能的，关键是看你每个请求处理需要耗费多长时间。

- mysql
8c16g 一两千并发
16c32g 两三千妥妥的，三四千有点吃力
一般8核16G的机器部署的MySQL数据库，每秒抗个一两千并发请求是没问题的，但是如果你的并发量再高一些，假设每秒有几千并发请求，那么可能数据库就会有点危险了
对于16核32G的机器部署的MySQL数据库而言，每秒抗个两三千，甚至三四千的并发请求也都是可以的


今天想留给大家一个小的思考题：假设你开发的Java系统部署在一台4核8G的机器上，那么我们假设这个Java系统处理一个请
求非常非常快，每个请求只需要0.01ms就可以处理完了，那你觉得这一台机器部署的Java系统，可以实现每秒抗下几千并发
请求吗？可以实现每秒抗下几万并发请求吗？
除了要考虑Java应用的处理速度，还要考虑网络、mysql的io

DBA这个时候会按照他过往的经验，用自己的MySQL生产调优参数模板，直接放到MySQL里去，然后用
一个参数模板去启动这个MySQL

你得基于一些工具模拟一个系统每秒发出1000个请求到数据库上去，观察一下他的CPU负载、磁盘IO负载、网络
IO负载、内存复杂，然后数据库能否每秒处理掉这1000个请求，还是每秒只能处理500个请求？这个过程，就是压测。

另外，我再给大家出另外一个思考题，假设现在你负责一个交易系统，对于这个交易系统，他拆分为了很多服务，一笔交易的
完成需要多个服务协作完成，也就是说一次交易请求需要调用多个服务才能完成。
那么你觉得对于每个服务而言，他每秒处理的请求数量是QPS还是TPS呢？对于整个交易系统而言，他每秒钟处理的交易笔数
是QPS还是TPS呢？请大家谈谈你的看法。

必须是不停的增加sysbench的线程数量，持续的让数据库承载更高的QPS，同时密切关注机器的
CPU、内存、磁盘和网络的负载情况.

QPS的数值的同时，机器的CPU、内存、网络和磁盘的负载已经比较高 了，到了一个有一定风险的临界值的了，此时就不能继续增加线程数量和提高数据库抗下的QPS了。


这个Buffer Pool默认情况下是128MB，还是有一点偏小了，我们实际生产环境下完全可以对Buffer Pool进行调整。
比如我们的数据库如果是16核32G的机器，那么你就可以给Buffer Pool分配个2GB的内存，使用下面的配置就可以了。
[server]
innodb_buffer_pool_size = 2147483648


- free 链表
首先，我们需要从free链表里获取一个描述数据块，然后就可以对应的获取到这个描述数据块对应的`空闲缓存页`，我们看下图

我们就可以把磁盘上的数据页读取到对应的缓存页里去，同时把相关的一些描述数据写入缓存页的描述数据块里去，比如
这个数据页所属的表空间之类的信息，最后把那个描述数据块从free链表里去除就可以了

2. 怎么知道数据页被缓存？
所以其实数据库还会有一个哈希表数据结构，他会用表空间号+数据页号，作为一个key，然后缓存页的地址作为value。

当你要使用一个数据页的时候，通过“表空间号+数据页号”作为key去这个哈希表里查一下，如果没有就读取数据页，如果已经有了，就说明数据页已经被缓存了。

也就是说我们写SQL的时候，只知道表+行的概念，但是在MySQL内部操作的时候，是表空间+数据页的概念。


- flush链表
不可能所有的缓存页都刷回磁盘的，因为有的缓存页可能是因为查询的时候被读取到Buffer Pool里去的，可能根本没修改过！
所以数据库在这里引入了另外一个跟free链表类似的flush链表，这个flush链表本质也是通过缓存页的描述数据块中的两个指
针，让被修改过的缓存页的描述数据块，组成一个双向链表。

我们用一些伪代码来给大家展示一下这个flush链表的构造过程，比如现在缓存页01被修改了数据，那么他就是`脏页`了，此时
就必须把他加入到flush链表中去

通过这个flush链表，就可以记录下来哪些缓存页是脏页了！

-LRU链表
- 预读
哪些情况下会触发MySQL的预读机制呢？
（1）有一个参数是innodb_read_ahead_threshold，他的默认值是56，意思就是如果顺序的访问了一个区里的多个
数据页，访问的数据页的数量超过了这个阈值，此时就会触发预读机制，把下一个相邻区中的所有数据页都加载到缓
存里去
（2）如果Buffer Pool里缓存了一个区里的13个连续的数据页，而且这些数据页都是比较频繁会被访问的，此时就会
直接触发预读机制，把这个区里的其他的数据页都加载到缓存里去
(3)接着我们讲另外一种可能导致频繁被访问的缓存页被淘汰的场景，那就是全表扫描
这个所谓的全表扫描，意思就是类似如下的SQL语句：SELECT * FROM USERS
此时他没加任何一个where条件，会导致他直接一下子把这个表里所有的数据页，都从磁盘加载到Buffer Pool里去。
2.预读的问题
LRU把链表尾部的数据页刷入磁盘（最少访问）

- 冷热数据解决lru预读问题
1.
冷数据占37%。

所以MySQL设定了一个规则，他设计了一个innodb_old_blocks_time参数，默认值1000，也就是1000毫秒
也就是说，必须是一个数据页被加载到缓存页之后，`在1s之后`，你访问这个缓存页，他才会被 `挪动到热数据区域的链
表头部去`。

2.
你会发现，预读机制和全表扫描加载进来的一大堆缓存页，此时都在冷数据区域里，跟热数据区
域里的频繁访问的缓存页，是没关系的！

3. 热数据区频繁移动
但是你要知道，热数据区域里的缓存页可能是经常被访问的，所以这么频繁的进行移动是不是性能也并不是太好？也
没这个必要。
所以说，LRU链表的热数据区域的访问规则被优化了一下，即你只有在热数据区域的后3/4部分的缓存页被访问了，才
会给你移动到链表头部去。
如果你是热数据区域的前面1/4的缓存页被访问，他是不会移动到链表头部去的。


- free链表、flush链表、lru链表
free链表、flush链表、lru链表都会在使用的时候同时被使用
比如数据加载到一个缓存页，free链表里会移除这个缓存页，然后lru链表的冷数据区域的头部会放入这个缓存页。
然后如果你要是修改了一个缓存页，那么flush链表中会记录这个脏页，lru链表中还可能会把你从冷数据区域移动到热
数据区域的头部去。


然后在缓存页都满的时候，必然要想办法把一些缓存页给刷入磁盘，然后清空这几个缓存页，接着把需要的数据页加载到缓存页里去！

这个定时任务每隔一段时间就会把LRU链表的冷数据区域的尾部的一些缓存页，刷入
磁盘里去，清空这几个缓存页，把他们加入回free链表去！

如果仅仅是把LRU链表中的冷数据区域的缓存页刷入磁盘，大家觉得够吗？
明显不够啊，因为在lru链表的热数据区域里的很多缓存页可能也会被频繁的修改，难道他们永远都不刷入磁盘中了
吗？
所以这个后台线程同时也会在MySQL不怎么繁忙的时候，找个时间把flush链表中的缓存页都刷入磁盘中，这样被你修
改过的数据，迟早都会刷入磁盘的！
只要flush链表中的一波缓存页被刷入了磁盘，那么这些缓存页也会从flush链表和lru链表中移除，然后加入到free链表
中去！


- 你的MySQL的内核参数，应该如何优化，优化哪些地方的行为，才能够尽可能的避免在执行CRUD的时候，经常要先刷一个缓存页到磁盘上去，才能读取一个磁盘上的数据页到空闲缓存页里来？

所以如果你的缓存页使用的很快，然后后台线程释放缓存页的速度很慢，那么必然导致你频繁发现缓存页被使用完
了。但是缓存页被使用的速度你是没法控制的，因为那是由你的Java系统访问数据库的并发程度来决定的，你高并发
访问数据库，缓存页必然使用的很快了！


- 生产经验：分配多个buffer pool

buffer pool是加锁的，多个请求是串行

一般来说，MySQL默认的规则是，如果你给Buffer Pool分配的内存小于1GB，那么最多就只会给你一个Buffer
Pool。
但是如果你的机器内存很大，那么你必然会给Buffer Pool分配较大的内存，比如给他个8G内存，那么此时你是同时可
以设置多个Buffer Pool的，比如说下面的MySQL服务器端的配置。
[server]
innodb_buffer_pool_size = 8589934592
innodb_buffer_pool_instances = 4
我们给buffer pool设置了8GB的总内存，然后设置了他应该有4个Buffer Pool，此时就是说，每个buffer pool的大小
就是2GB
这个时候，MySQL在运行的时候就会有4个Buffer Pool了！每个Buffer Pool负责管理一部分的缓存页和描述数据块，
有自己独立的free、flush、lru等链表。

- 生产经验：如何通过chunk来支持数据库运行期间的Buffer Pool动态调整？
他实际上设计了一个chunk机制，也就是说buffer pool是由很多chunk组
成的，他的大小是innodb_buffer_pool_chunk_size参数控制的，默认值就是128MB。

那么现在有了上面讲的这套chunk机制，就可以支持动态调整buffer pool大小了。
比如我们buffer pool现在总大小是8GB，现在要动态加到16GB，那么此时只要申请一系列的128MB大小的chunk就
可以了，只要每个chunk是连续的128MB内存就行了。然后把这些申请到的chunk内存分配给buffer pool就行了。
有个这个chunk机制，此时并不需要额外申请16GB的连续内存空间，然后还要把已有的数据进行拷贝。

- 生产经验：在生产环境中，如何基于机器配置来合理设置Buffer Pool？

SHOW ENGINE INNODB STATUS

表空间 

COMPACT行存储
变长字段的长度列表，null值列表，数据头，column01的值，column02的值，column0n的值......
对于每一行数据，他其实存储的时候都会有一些头字段对这行数据进行一定的描述，然后再放上他这一行数据每一列
的具体的值，这就是所谓的行格式。除了COMPACT以外，还有其他几种行存储格式，基本都大同小异。


hello a a hi a a
大家可以看到，两行数据在底层磁盘文件里是不是挨着存储的？
没错！其实平时你看到的表里的很多行数据，最终落地到磁盘里的时候，都是上面那种样子的，一大坨数据放在一个
磁盘文件里都挨着存储的。


要带上一些额外的附加信息，比如第一块就是他里面的变长字段
的长度列表
也就是说，这个hello是VARCHAR(10)类型的变长字段的值，那么这个“hello”字段值的长度到底是多少？
我们看到“hello”的长度是5，十六进制就是0x05，所以此时会在“hello a a”前面补充一些额外信息，首先就是变
长字段的长度列表，你会看到这行数据在磁盘文件里存储的时候，其实是类似如下的格式：0x05 null值列表 数据头
hello a a。

0x05 null值列表 数据头 hello a a 0x02 null值列表 数据头 hi a a


- null值在数据库的存储
所以实际在磁盘上存储数据的时候，一行数据里的NULL值是肯定不会直接按照字符串的方式存放在磁盘上浪费空间
的。

那就是如果这个变长字段的值是NULL，就不用在变长字段长度列表里
存放他的值长度了，所以在上面那行数据中，只有name和school两个变长字段是有值的，把他们的长度按照逆序放在
变长字段长度列表中就可以了，如下所示：

0x09 0x04 0101 头信息 column1=value1 column2=value2 ... columnN=valueN