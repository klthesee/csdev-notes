
3. 
接解优执

对他加锁之后，而且还把更新前的旧值写入undo日志文件
之后，我们就可以正式开始更新这行记录了，更新的时候，先是会更新缓冲池中的记录，此时这个数据就是脏数据
了。

- 为什么叫脏数据？
因为buffer pool和undo log 更新了，但是硬盘没有更新。

redo log 记录新数据
当这个参数的值为1的时候，你提交事务的时候，就必须把redo log从内存刷入到磁盘文件里去，只要事务提交成功，那么redo log就
必然在磁盘里了，

bin log 不是属于特定存储引擎，而是mysql server的
sync_binlog参数可以控制binlog的刷盘策略
0 刷入os cache
1 刷入磁盘文件

同时给redo log 写入一个commit标记才算提交事务。

开发经验
Java应用系统部署的时候常选用的机器配置大致是2核4G和4核8G的较多一些，
数据库部署的时候常选用的机器配置最低在8核16G以上，正常在16核32G

- java程序
4核8G的机器部署普通的Java应用系统，每秒大致就是抗下几百的并发访问，从每秒一两百请求到每秒七八百请
求，都是有可能的，关键是看你每个请求处理需要耗费多长时间。

- mysql
8c16g 一两千并发
16c32g 两三千妥妥的，三四千有点吃力
一般8核16G的机器部署的MySQL数据库，每秒抗个一两千并发请求是没问题的，但是如果你的并发量再高一些，假设每秒有几千并发请求，那么可能数据库就会有点危险了
对于16核32G的机器部署的MySQL数据库而言，每秒抗个两三千，甚至三四千的并发请求也都是可以的


今天想留给大家一个小的思考题：假设你开发的Java系统部署在一台4核8G的机器上，那么我们假设这个Java系统处理一个请
求非常非常快，每个请求只需要0.01ms就可以处理完了，那你觉得这一台机器部署的Java系统，可以实现每秒抗下几千并发
请求吗？可以实现每秒抗下几万并发请求吗？
除了要考虑Java应用的处理速度，还要考虑网络、mysql的io

DBA这个时候会按照他过往的经验，用自己的MySQL生产调优参数模板，直接放到MySQL里去，然后用
一个参数模板去启动这个MySQL

你得基于一些工具模拟一个系统每秒发出1000个请求到数据库上去，观察一下他的CPU负载、磁盘IO负载、网络
IO负载、内存复杂，然后数据库能否每秒处理掉这1000个请求，还是每秒只能处理500个请求？这个过程，就是压测。

另外，我再给大家出另外一个思考题，假设现在你负责一个交易系统，对于这个交易系统，他拆分为了很多服务，一笔交易的
完成需要多个服务协作完成，也就是说一次交易请求需要调用多个服务才能完成。
那么你觉得对于每个服务而言，他每秒处理的请求数量是QPS还是TPS呢？对于整个交易系统而言，他每秒钟处理的交易笔数
是QPS还是TPS呢？请大家谈谈你的看法。

必须是不停的增加sysbench的线程数量，持续的让数据库承载更高的QPS，同时密切关注机器的
CPU、内存、磁盘和网络的负载情况.

QPS的数值的同时，机器的CPU、内存、网络和磁盘的负载已经比较高 了，到了一个有一定风险的临界值的了，此时就不能继续增加线程数量和提高数据库抗下的QPS了。


这个Buffer Pool默认情况下是128MB，还是有一点偏小了，我们实际生产环境下完全可以对Buffer Pool进行调整。
比如我们的数据库如果是16核32G的机器，那么你就可以给Buffer Pool分配个2GB的内存，使用下面的配置就可以了。
[server]
innodb_buffer_pool_size = 2147483648


- free 链表
首先，我们需要从free链表里获取一个描述数据块，然后就可以对应的获取到这个描述数据块对应的空闲缓存页，我们看下图

我们就可以把磁盘上的数据页读取到对应的缓存页里去，同时把相关的一些描述数据写入缓存页的描述数据块里去，比如
这个数据页所属的表空间之类的信息，最后把那个描述数据块从free链表里去除就可以了

怎么知道数据页被缓存？
所以其实数据库还会有一个哈希表数据结构，他会用表空间号+数据页号，作为一个key，然后缓存页的地址作为value。

当你要使用一个数据页的时候，通过“表空间号+数据页号”作为key去这个哈希表里查一下，如果没有就读取数据页，如果已经有了，就说明数据页已经被缓存了。

也就是说我们写SQL的时候，只知道表+行的概念，但是在MySQL内部操作的时候，是表空间+数据页的概念。


不可能所有的缓存页都刷回磁盘的，因为有的缓存页可能是因为查询的时候被读取到Buffer Pool里去的，可能根本没修改过！
所以数据库在这里引入了另外一个跟free链表类似的flush链表，这个flush链表本质也是通过缓存页的描述数据块中的两个指
针，让被修改过的缓存页的描述数据块，组成一个双向链表。